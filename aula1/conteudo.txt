Programação Dinâmica

- Estrutura de dados : Lista, pilha, árvore binárias, fila

    Lista sequencial : Lista estática, não muda a lista. Imutável

    Fila : Envolve algoritmos da area de grafos para percorrer estrutura. Por exemplo, resolver problemas de custo mínimo

    Pilha : Verificar se uma expressão está correta ou não.

    Árvores binárias : O primeiro elemento é a raiz. 

- Algorítmos de ordenação

    V[i] < V[j]

    Insertion :
    Selection :
    Bubble :

    *Não esxiste sobreposição de problemas
    Mergesort :
    Quicksort :

- Algorítmos de busca

    Busca sequencial : 
    Busca binária : Vetor que tenha uma ordenação para fazer uma busaca mais rápida. Ao invés de varrer faz a busca binária. Sempre calcula primeiro o meio da lista.

- Técnicas de Algorítmos

    Algoritmos gulosos : Monta a solução de acordo com inserir elementos novos em uma lista não necessariamente vazia. Então vai ter uma lista para solução  e vai ser colocado um elemento , e a ideia é ele nunca mais sair de lá.
    Programação dinâmica : 



CODIGO SWITCH 

// Criando variáveis
// As variáveis sao tipadas

var nome: String = "Felipe"
var idade: Int = 21
print(idade)

// Interpolacao, imprimir uma variável depois de um texto
print("Meu nome é :  \(nome)")

// Variável let é constante e nao pode ter valor alterado.
let altura: Double = 1.75
print("A minha altura é \(altura)")

var coeficienteRendimento: Double = 9.5
var possuiHistoricoReprovacao: Bool
possuiHistoricoReprovacao = false

var turnoEmQueEstuda: Character = "D"

// Type alias
typealias Estudante = String
var aluno1: Estudante = "Joao"
var aluno2: Estudante = "Ana"

// Operacoes artmeticas e de atribuicao

10 + 2
10 - 2
8 * 2
5 / 3
5.0 / 2
4 % 2
// Segue a ordem, primeiro vem a multiplicacao
5 + 2 * 7
// Faz a adicao primeiro
(5 + 2) * 10

var numero1: Int = 50
var numero2: Int = 100
var soma = numero1 + numero2
print(soma)

numero1 +=  2
print(numero1)


var Primeironome = "Felipe"
var sobrenome = "Casquet"
print("Meu nome é \(Primeironome) \(sobrenome)")


// Operadores relacionais e lógico
// Aplicativo que armazena pontuacao de usuarios

var pontuacao1 = 8.0
var pontuacao2 = 10.0
// Saber se uma pontuacao é maior que outra : Operadores relacionais

// Primeiro operador relacional >
pontuacao1 > pontuacao2
pontuacao1 <= pontuacao2
pontuacao1 < pontuacao2
pontuacao1 <= pontuacao2
pontuacao1 == pontuacao2
pontuacao1 != pontuacao2

var usuarioVenceu = pontuacao2 > pontuacao1

// Operadores logicos para verificar se a pessoa pode dirigir
var idadePessoa = 21
// Ser maior que 18
var adulto = idadePessoa >= 18
// Possui CNH
var possuiCnhValida = true
// Para dirigir é preciso ser adulto e ter cnh.
var podeDirigir = adulto && possuiCnhValida
// Inverte o estado do booleano
!adulto


// Condicionais if elseif else
// Exemplo da carteira cnh

var idadeMotorista = 15

if idadeMotorista >= 18 {
    
    print("Pode iniciar processo de tirar carta")
    
}else{
    
    print("Nao pode tirar carta")
    
}

var possuiCnhvalida = true

if idade >= 18 && possuiCnhvalida{
    
    print("Pode dirigir")
    
}else {
    
    print("Nao pode dirigir")
    
}

var num1 = 5
var num2 = 10

if num2 > num1{
    
    print("Número 2 é maior que numero 1")
    
} else if num1 > num2 {
    
    print("Numero 1 é maior que numero 2")
} else {
    
    print("Numero 1 é igual a numero 2")
}


// Intervalos de valores
// Intervalo fechado e semiaberto

var intervaloFechado = 10...20 // 20 esta incluso
var intervaloSemiAberto = 10..<20 // 20 nao esta incluso

var numero = 20

// Switch case para verificar se o numero 25 esta no intervalo entre 0 e 10
switch numero {
    
case 0...10: print("Numero esta entre 0 e 10")
case 10...20: print("Numero esta entre 10 e 20")
default: print("Numero é maior que 20")
    
}

// Utilizando Switch case para verificar  multiplos valores

var animal = "Cachorro"

switch animal {
    
case "Cachorro", "Gato": print("Animal domestico")
default: print("Animal selvagem")
    
}

// Utilizando switch para verificar se o numero e par ou impar

switch numero {
   
    case let x where x % 2 == 0: print("Numero \(x) é par")
    case let x where x % 2 != 0: print("Numero \(x) é impar")
    default: break
    
}

// Lacos de repeticao. For while Repeat while

/*for i in 1...10{
    
    print(i)
    
}*/

var count = 11

/*while count <= 10 {
    print("Eu gosto de switch")
    count += 1
}*/

repeat{
    print("Eu gosto de switch")
} while count <= 10


var somaIntervalo = 0

for i in 1...10{
    
    somaIntervalo += i
    
}

print(somaIntervalo)

// Utilizando break e continue
var count1 = 1

while count1 <= 10 {
    count1 += 1
    if count1 == 5 {
        break
    }
    print(count1)
}

var count2 = 1

while count2 <= 10 {
    count2 += 1
    if count2 == 5 {
        continue
    }
    print(count2)
}


// Conceito de funcao. Bloco de codigo que executa uma tarefa
// Funcao para somar dois numeros

func somaFunc(_ numeroUm:Int, _ numeroDois:Int) -> Int{
    var resultado = numeroUm + numeroDois
    return resultado
}

var somaRetorno = somaFunc(5, 3)
print(somaRetorno)

// Verificar se a pessoa é adulta

func verificaAdulto(_ idade:Int) -> Bool{
    
    return idade >= 18
    
}

var verificar = verificaAdulto(21)
print(verificar)


// Entendo opcionais

var telefone: String?
telefone = "999"

if telefone != nil{
    print(telefone!)
}

var celular: String?
celular = "88888"

if let telefone = telefone, let celular = celular{
    print(telefone)
    print(celular)
}


func autenticar(usuario: String?, senha: String?){
    
    guard let usuario = usuario, let senha = senha
    else { return }
    print(usuario)
    print(senha)
}

autenticar(usuario: "felipe", senha:nil)


if let primeiroCaractere = telefone?.first {
    print(primeiroCaractere)
}

print(telefone ?? "Nao tem valor para telefone")

// Arrays

var notas: [Double] = [8.5,9.0,7.2,6.0]

// Array vazio

var arrayVazio = Array<String>()

notas.isEmpty
arrayVazio.isEmpty

notas.count
notas.min()
notas.max()
notas.contains(4.0)
notas.firstIndex(of: 10.0)

notas.append(10)
notas.insert(5.0, at: 2)
notas += [8.2]
print(notas)

var elementoRemovido = notas.removeFirst()
print(elementoRemovido)
print(notas)

for nota in notas {
    print(nota)
}


// Sets, tipo de dado desordenado

var nomes: Set<String> = ["felipe", "caio", "giovana"]

nomes.contains("felipe")
nomes.insert("carla")


// Tuplas

/*typealias Coordenadas = (x: 5, y: 3.5, z: 8.0)
var coordenadas: (Int, Double) = (x: 5, y: 3.5, z: 8.0)
coordenadas.x
coordenadas.y
coordenadas.z

var pessoa = (nome: "felipe", idade:21)
pessoa.nome
pessoa.idade

var (_nome, _idade) = pessoa
print(pessoa)*/

var pontuacao = [
    "joao":20,
    "felipe":21,
    "gilson":20
]

var pessoas: [String: Int] = [:]
pessoas.reserveCapacity(10)

print(pontuacao["felipe"])
pontuacao["gui"] = 30
print(pontuacao)



CURSO 2

import UIKit

// Uma opcional pode conter ou nao conter um valor

// Caso menos seguro
var nome:String?
nome = "Felipe"
print(nome!)


// É preciso desembrulhar um opcional que tem valor para verificar se realmente a variável nao tem um valor vazio

// Caso mais seguro
var nome2:String?
nome2 = "Leticia"

if nome2 != nil {
    print(nome2!)
}

// Metodo binding, bordagem mais segura para desembrulhar uma opcional

var nomeAluno:String?
nomeAluno = "Felipe"

if let nome = nomeAluno{
    print(nome)
}

// Utilizandi multiplas opcionais dentro de uma condicao

var nomeProfessor:String?
var nomeProfessora:String?
nomeProfessor = "Francisco"
nomeProfessora = "Liliane"

if let nomeMulher = nomeProfessora, let nomeHomem = nomeProfessor{
    print(nomeMulher)
    print(nomeHomem)
}


// Optional Chaining
// O código roda apenas se a opcional possuir de fato um valor

var nomeCarol:String?
nomeCarol = "Carol"
print(nomeCarol?.first)


// Combinando optional binding com optional changing

var nomeMarcelo:String?
nomeMarcelo = "Marcelo"

if let primeiraLetra = nomeMarcelo?.first{
    print(primeiraLetra)
}


// Guard let
//Parecido com o optional binding porem se a opcional for nula , retorna algo

func autenticar(nome:String?, senha:String?){
    guard let nomeN = nome, let senhaS = senha else { return }
    print(nomeN)
    print(senhaS)
}

autenticar(nome:"Felipe", senha:"felipe123")

// Nil coalescing operator

// Ele aceita uma expressão à esquerda, que é a variável opcional, e uma expressão à direita, que é o valor que tomará lugar caso a variável opcional for nil.

var nomeCoordenador:String?
nomeCoordenador = "Allen"
print(nomeCoordenador ?? "Inexistente")


// Orientacao a objetos


// Structs

struct ContaCorrente{
    
    var saldo = 0.0 // Atributo
    var nome: String
    
    mutating func sacar(_ valor:Double){ // Metodo multating faz o atributo poder ser alterado
        
        saldo -= valor
    }
    
    mutating func depositar(_ valor:Double){
        
        saldo += valor
        
    }
}

// Instanciando a classe

var contaCorrenteFelipe = ContaCorrente(nome:  "Felipe")
print(contaCorrenteFelipe.saldo)
contaCorrenteFelipe.depositar(3000)
print(contaCorrenteFelipe.saldo)

var contaCorrenteCaio = ContaCorrente(nome:  "Eitor")
contaCorrenteCaio.depositar(200)
print(contaCorrenteCaio.saldo)
contaCorrenteCaio.sacar(50)
print(" Saldo disponível de Caio : \(contaCorrenteCaio.saldo)")


// Classes. Nao precisa da palavra mutating . Precisa definir um construtor


class ContaCorrenteDois{
    
    var saldo: Double // Atributo
    var nome: String
    
     func sacar(_ valor:Double){
        
        saldo -= valor
    }
    
     func depositar(_ valor:Double){
        
        saldo += valor
        
    }
    
    init(nome:String){
        
        saldo = 0.0
        self.nome = nome
    }
}

// Instanciando a classe

var contaCorrenteBreno = ContaCorrenteDois(nome:  "Breno")
print(contaCorrenteBreno.saldo)
contaCorrenteBreno.depositar(5000)
print("saldo disponivel de breno : \(contaCorrenteBreno.saldo)")

var contaCorrenteItamar = ContaCorrenteDois(nome:  "Itamar")
contaCorrenteItamar.depositar(20000)
print(contaCorrenteItamar.saldo)
contaCorrenteItamar.sacar(50)
print(" Saldo disponível de itamar : \(contaCorrenteItamar.saldo)")


// Classes possui um contexto chamado Heranca

// Heranca

class ContaBancaria{
    
    var saldoConta = 0.0
    
    var nomeProprietario:String
    
    func sacarValor(_ valorConta:Double){
        
        saldoConta -= valorConta
        
    }
    
    func depositarValor(_ valorConta:Double){
        
        saldoConta += valorConta
        
    }
    
    
    init(nomeProprietario:String){
        self.nomeProprietario = nomeProprietario
    }
}

// criando subclasse
class ContaBancariaPoupanca: ContaBancaria{
    
    var possuiCartaoDebito: Bool
    
    func solicitarCartaoDebito(){
        
        possuiCartaoDebito = true
        print("Solicitando cartao debito")
    }
    
    override func sacarValor(_ valorConta:Double){
        
        saldoConta -= valorConta + 10
        
    }
    
    init(nomeProprietario:String, possuiCartaoDebito: Bool){
        self.possuiCartaoDebito = possuiCartaoDebito
        super.init(nomeProprietario: nomeProprietario )
    }
    
}
// instanciando subclasse
var contaBancariaPoupanca =  ContaBancariaPoupanca(nomeProprietario: "Felipe", possuiCartaoDebito: true)
contaBancariaPoupanca.depositarValor(1900.0)
contaBancariaPoupanca.sacarValor(400)
print(contaBancariaPoupanca.saldoConta)
contaBancariaPoupanca.solicitarCartaoDebito()

// criando subclasse
class ContaBancariaCorrente: ContaBancaria {
    
    func pedirEmprestimo(_ valorEmprestimo:Double){
        
        print(" O cliente esta pedindo um emprestimo no valor de \(valorEmprestimo)")
        
        super.depositarValor(valorEmprestimo) // Super . Chamar um metodo da classe pai na clsse filha
        
    }
    
    override func sacarValor(_ valorConta: Double) {
        
        saldoConta -= valorConta + 10
        
    }
    
}
// instanciando subclasse
var contaBancariaCorrente = ContaBancariaCorrente(nomeProprietario: "Felipe")
contaBancariaCorrente.depositarValor(1700)
contaBancariaCorrente.sacarValor(300)
print(contaBancariaCorrente.saldoConta)
contaBancariaCorrente.pedirEmprestimo(50000)
print(contaBancariaCorrente.saldoConta)

// Polimorfismo

func exibeSaldoDaConta(_ conta: ContaBancaria){
    
    if conta is ContaBancariaCorrente{
        print("Conta do tipo corrente")
    }
    
    if let contaBancariaCorrente = conta as? ContaBancariaCorrente{
        contaBancariaCorrente.pedirEmprestimo(600)
    }
    
    guard let contaBancariaPoupanca = conta as? ContaBancariaPoupanca else { return }
    
    print(contaBancariaPoupanca.possuiCartaoDebito)
    
}

exibeSaldoDaConta(contaBancariaCorrente)
exibeSaldoDaConta(contaBancariaPoupanca)


// Propriedades armazenadas, computadas e estaticas

class ContaNubank{
    // armazenada
    var saldo = 0.0 {
        willSet{
            print(" O saldo esta sendo alterado, seu novo valor é \(newValue)")
        }
        
        didSet{
            print(" O valor antigo é \(oldValue)")
        }
    }
    var nome:String
    // computada.Realiza calculo. precisa ter o tipo de forma explicita
    var negativado: Bool{
        return saldo < 0
    }
    
    static var taxaTransferencia = 0.1
    
    func sacar(_ valor:Double){
        saldo -= valor
    }
    
    func depositar(_ valor:Double){
        saldo += valor
    }
    
    func transferir(_ contaDestino: ContaNubank, _ valor:Double){
        sacar(valor)
        contaDestino.depositar(valor)
    }
    
    init(nome:String){
        self.nome = nome
    }
    
}
// extensao
/*extension ContaNubank {
    func transferir(_ contaDestino: ContaNubank, _ valor:Double){
        sacar(valor)
        contaDestino.depositar(valor)
    }
}*/

func  contaCaracteresString(_ texto:String) -> Int{
    return texto.count
}



let texto = "Felipe"
contaCaracteresString(texto)

var contaCorrenteNubank = ContaNubank(nome: "Felipe")
contaCorrenteNubank.depositar(5000)
print(contaCorrenteNubank.saldo)
contaCorrenteNubank.negativado

var contaCorrenteBrasil = ContaNubank(nome: "Itamar")
contaCorrenteNubank.transferir(contaCorrenteBrasil, 1000)
print(contaCorrenteNubank.saldo)
print(contaCorrenteBrasil.saldo)

// protocolos

protocol Tesouro {
    var saldo:Double { get set }
    
    func sacar(_ valor:Double)
    func depositar(_ valor:Double)
}

class TesouroCorrente: Tesouro {
    var saldo: Double
    
    func sacar(_ valor: Double) {
        saldo -= valor
    }
    
    func depositar(_ valor: Double) {
        saldo += valor
    }
    
    init(){
        saldo = 0.0
    }
    
}

// enumeracoes , raw value
enum FormaDePagamento{
    case pix
    case boleto
    case saldoEmConta
}

enum ResultadoSaque{
    case sucesso(novoValor: Double)
    case falha(erro:String)
}


class Banco{
    var saldo = 0.0
    var nome: String
    
    func sacar(_ valor:Double) -> ResultadoSaque{
        if valor > saldo{
            return .falha(erro: "O valor é maior que o seu saldo")
        }else {
            saldo -= valor
            return .sucesso(novoValor:saldo)
        }
        saldo -= valor
    }
    
    func depositar(_ valor:Double){
        saldo += valor
    }
    
    func pagamentoCartao(_ tipoPagamento: FormaDePagamento){
        switch tipoPagamento{
        case .pix:print(" Pagamento sera efetuado por pix")
        case .boleto:print(" O pagamento sera efetuado por boleto")
        case .saldoEmConta:print(" O paga,ento sera efetuado por saldo em conta")
        }
    }
    
    init(nome:String){
        self.nome = nome
    }
}

var  bancoFelipe = Banco(nome:"Felipe")
bancoFelipe.pagamentoCartao(.pix)
bancoFelipe.depositar(500)
let resultado = bancoFelipe.sacar(100)

switch resultado {
    
case .sucesso(let novoValor):
    print("saque sucesso \(novoValor)")
    
case .falha(let erro):
    print(erro)
}

enum Mes:Int {
    case janeiro, fevereiro, marco,abril,maio,junho,julho, agosto,setembro,outubro,novembro,dezembro
}

var janeiro = Mes.janeiro
print(janeiro.rawValue)

var fevereiro:Mes = .fevereiro
print(fevereiro.rawValue)

enum Moeda: Double {
    case umCentavo = 0.01
    case cincoCentavos = 0.05
    case dezCentavos = 0.1
    case vinteCincoCentavos = 0.25
    case cinquentaCentavos = 0.50
}

var umcentavo = Moeda.umCentavo
print(umcentavo.rawValue)

// Associated values. lidar com caso de sucesso para algo valido e fracasso para algo nao valido.


















